<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Python, Yazılım, ve Programlama (mathjax ile ilgili yazılar)</title><link>http://ysar.net/</link><description></description><atom:link href="http://ysar.net/categories/mathjax.xml" type="application/rss+xml" rel="self"></atom:link><language>tr</language><lastBuildDate>Mon, 03 Sep 2018 23:34:19 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Kamera Arkası: Python Sözlükler</title><link>http://ysar.net/python/kamera-arkasi-sozlukler.html</link><dc:creator>Yaşar Arabacı</dc:creator><description>&lt;div&gt;&lt;p&gt;10 yılı aşkın süredir programlama öğreniyorum. Bu uzun zaman zarfı içerisinde, &lt;a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html"&gt;glibc belgelerinin&lt;/a&gt; çoğunu
okumak, &lt;a href="http://www.dipmat.univpm.it/~demeio/public/the_c_programming_language_2.pdf"&gt;referans kitaplar okumak&lt;/a&gt;, &lt;a href="https://stackoverflow.com/users/886669/yasar?tab=questions&amp;amp;sort=votes"&gt;soru sormak&lt;/a&gt;,
&lt;a href="http://ysar.net/soru-cevap.html"&gt;soru cevaplamak&lt;/a&gt;, &lt;a href="https://github.com/yasar11732/CodeIgniter-Belge-Cevirisi"&gt;belge çevirmek&lt;/a&gt; ve &lt;a href="http://ysar.net/"&gt;blog yazmak&lt;/a&gt; gibi envai çeşit aktivitenin içerisinde
bulundum. Bunca aktivitenin içinde hiçbiri, kendimden daha deneyimli ve becerikli programcılar tarafından yazılan kodları okumak kadar hızlı fayda vermedi. Bu demek değil
ki, saydığım onca şeyin bir faydasını görmedim. Onlar olmadan, okuduğum kodları anlayabilecek ve kendi kodlarıma tatbik edebilecek temel bilgilere sahip olamazdım. Ancak,
temel bilgiler öğrenmenin ve standart programlar yazmanın eğitsel katkısı kaybolmaya başladığında, profesyonel programcılar tarafından yazılmış, birçok kişi tarafından
kullanılan kodlar, yeni veya daha rafine fikirler edinmeme yardımcı oldu. Bu şekilde faydalandığım kaynaklardan biri de, &lt;a href="https://github.com/python/cpython/blob/2.7/Objects/dictobject.c"&gt;Python sözlük objesi kaynak kodları&lt;/a&gt;. Dinamik array ve Hash Table (Tr. Komut Çizelgesi)
özelliklerine sahip bu ilginç veri yapısı, &lt;em&gt;keyword&lt;/em&gt; argümanları, sınıfların metodları, global ve gömülü değişkenler gibi, bir anahtarla veriyi
eşlemek gereken her yerde kullanılıyor. Bu yüzden Python için önemli bir yeri var. &lt;/p&gt;
&lt;p&gt;Büyük bir projenin kaynak kodlarını okumak, çoğu zaman korkutucudur. Neyse ki, &lt;code&gt;dictobject.c&lt;/code&gt; içindeki yorumlar öyle açık ki, tahmine gerek bırakmıyor.
Bu yazının büyük bir kısmı, &lt;code&gt;dictobject.c&lt;/code&gt; içindeki yorumların kendi kelimelerimle ifadesinden ibaret olacak. Burada bahsedilen konuları anlamak için, giriş seviyesinde Python bilgisi,
orta derecede C bilgisi, temel veri yapıları konusunda bilgi sahibi olmanız faydalı olacaktır.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Not&lt;/strong&gt;: Buradaki inceleme Python 2.7'deki &lt;code&gt;dictobject.c&lt;/code&gt; dosyası üzerinden yapıldı, &lt;a href="https://raw.githubusercontent.com/python/cpython/3.7/Objects/dictobject.c"&gt;bu dosyanın 3.7 deki halinde&lt;/a&gt;
ciddi farklılıklar var.&lt;/p&gt;
&lt;p&gt;Python sözlükleri C dilinde hash tablosu olarak tasarlanmış. Tablonun her bir girdisi, aşağıdaki yapıda;&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Cached hash code of me_key.  Note that hash codes are C longs.&lt;/span&gt;
&lt;span class="cm"&gt;     * We have to use Py_ssize_t instead because dict_popitem() abuses&lt;/span&gt;
&lt;span class="cm"&gt;     * me_hash to hold a search finger.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;me_hash&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;me_key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;me_value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;PyDictEntry&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;struct&lt;/code&gt; yapısı çok basit. Sözlük anahtarı olarak kullanılan objenin &lt;code&gt;hash&lt;/code&gt; değeri, anahtar ve değer olarak kullanılan objeleri
işaret eden pointerlar var. Tablo içindeki bu girdilerin her birine slot deniyor. Bir slotun, 3 farklı tipi olabiliyor. Kullanılmamış
slotlarda, &lt;code&gt;me_key&lt;/code&gt; ve &lt;code&gt;me_value&lt;/code&gt; değerleri &lt;code&gt;NULL&lt;/code&gt; oluyor. Aktif slotlarda, &lt;code&gt;me_key != NULL &amp;amp;&amp;amp; me_key != dummy&lt;/code&gt; ve &lt;code&gt;me_value != NULL&lt;/code&gt;
oluyor. Dummy diye adlandırdıkları slotlar ise, eskiden geçerli bir (anahtar, değer) barındıran ama şu an boş olan slotlar. Bunlarda
ise, &lt;code&gt;me_key == dummy&lt;/code&gt; ve &lt;code&gt;me_value == NULL&lt;/code&gt; oluyor. &lt;code&gt;dummy&lt;/code&gt; ilk kez sözlük objesi oluşturulduğunda bir defaya mahsus olmak üzere
oluşturulan ve tek amacı bir hash tablosu slotunun boş olduğunu belirtmek olan bir Python objesi. Bunun neden gerekli olduğu, ekleme
ve arama bölümlerinde açıklanacak.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;_dictobject&lt;/span&gt; &lt;span class="n"&gt;PyDictObject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;_dictobject&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PyObject_HEAD&lt;/span&gt;
    &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;ma_fill&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* # Active + # Dummy */&lt;/span&gt;
    &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;ma_used&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* # Active */&lt;/span&gt;

    &lt;span class="cm"&gt;/* The table contains ma_mask + 1 slots, and that's a power of 2.&lt;/span&gt;
&lt;span class="cm"&gt;     * We store the mask instead of the size because the mask is more&lt;/span&gt;
&lt;span class="cm"&gt;     * frequently needed.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;ma_mask&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* ma_table points to ma_smalltable for small tables, else to&lt;/span&gt;
&lt;span class="cm"&gt;     * additional malloc'ed memory.  ma_table is never NULL!  This rule&lt;/span&gt;
&lt;span class="cm"&gt;     * saves repeated runtime null-tests in the workhorse getitem and&lt;/span&gt;
&lt;span class="cm"&gt;     * setitem calls.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;PyDictEntry&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ma_table&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PyDictEntry&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ma_lookup&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;PyDictObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;PyDictEntry&lt;/span&gt; &lt;span class="n"&gt;ma_smalltable&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;PyDict_MINSIZE&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;ma_fill&lt;/code&gt; değişkeni
toplam aktif ve dummy slotlarının sayısını tutarken, &lt;code&gt;ma_used&lt;/code&gt; değişkeni ise, aktif kayıtların sayısını tutuyor. &lt;code&gt;ma_mask&lt;/code&gt; değişkeni
hash tablosunun kapasitesinin bir eksiğini tutuyor. Bunun neden gerekli olduğunu da ekleme ve arama bölümlerinde açıklanacak, şimdilik
bu haliyle kabul edin. &lt;code&gt;ma_table&lt;/code&gt; değişkeni ise, tablo için ayrılmış alana işaret eden bir pointer. Sözlük objesi ilk oluşturulduğunda,
&lt;code&gt;ma_table = &amp;amp;(ma_smalltable[0])&lt;/code&gt; oluyor. Böylece, küçük tablolar için (5 elemana kadar) ayrıca bir &lt;code&gt;malloc&lt;/code&gt; çağrısı yapmaya gerek kalmıyor.
&lt;code&gt;PyObject_HEAD&lt;/code&gt; makrosu ve &lt;code&gt;ma_lookup&lt;/code&gt; fonksiyonu birebir konumuzla alakalı değil. &lt;/p&gt;
&lt;h3&gt;Arama ve Ekleme&lt;/h3&gt;
&lt;p&gt;Tüm hash tabloları gibi, Python'daki sözlükler de, Python objelerinin hash değerini hesaplayıp, bu değeri aranılan
nesneyi tablo için bulmak için kullanıyor. Ancak, Python sözlüklerinde kullanılan hash tablolarında bazı nüanslar var.
Öncelikle, yaygın kullanılan hash fonksiyonları, hash değerlerini rastgele-gibi dağıtır. Python hash fonksiyonları
bunun aksine gayet düzenlidir. Örneğin;&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; map(hash, range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&amp;gt;&amp;gt;&amp;gt; map(hash, ("aaa","aab","aac","aad"))
[-1599925404, -1599925401, -1599925402, -1599925407]
&lt;/pre&gt;


&lt;p&gt;Buradan anlaşılacağı üzere, her bir tam sayının hash değeri kendisine eşittir. Sıralı giden &lt;code&gt;string&lt;/code&gt; objelerinin hash
değerleri ise, birbirine yaklaşık olur. Hash fonksiyonlarının bu özelliğini, şu şekilde gerekçelendirmişler;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This isn't necessarily bad!  To the contrary, in a table of size 2**i, taking
the low-order i bits as the initial table index is extremely fast, and there
are no collisions at all for dicts indexed by a contiguous range of ints.
The same is approximately true when keys are "consecutive" strings.  So this
gives better-than-random behavior in common cases, and that's very desirable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Açıklamayı kısaca özetlemek gerekirse; ardışık sayı veya metinlerin sözlük
indeksi olarak kullanılması yaygın olduğundan, ardışık hash değerlerinde
herhangi bir çakışma olması söz konusu değildir. Neticede, yaygın kullanımlar
için, rastgeleden-iyi performans sergileriz.&lt;/p&gt;
&lt;p&gt;Hash değerlerini tablo indekslerine çevirme konusu ise, bit maskeleme
yöntemi ile yapılıyor. Bunun için, tablo kapasitesi her zaman 2'nin
kuvveti şeklinde tutuluyor. Maske olarak kullanılan değer ise, tablo
kapasitesinin bir eksiği oluyor. Örneğin, tablo kapasitesi 8 olduğunda,
maske değeri 7 ( binary olarak 00000111 ) oluyor. İndeks ise, &lt;code&gt;hash&amp;amp;mask&lt;/code&gt;
şeklinde hesaplanıyor. Diğer bir deyişle, &lt;code&gt;2**i&lt;/code&gt; büyüklüğünde bir tablo için,
hash değerinin alttan &lt;code&gt;i&lt;/code&gt; biti tablo indeksi oluyor.&lt;/p&gt;
&lt;p&gt;Genel olarak hash tablolarında, çakışma çözümlemek için iki yöntem vardır. Bunlardan biri,
hash tablosunun her bir slotunda, linked list (tr. bağlı liste) veri yapısı
bulundurmakır (en. seperate chaining). Bu yöntemde, aynı hash değerini
taşıyan elemanlar, bir liste içinde tutulur. Diğer bir yöntem ise, eğer
birden fazla eleman aynı hash değerine sahipse, eleman hash
tablosunda farklı boş bir yerde tutulur (en. open addressing). Python sözlükleri,
bu ikinci bahsettiğim metodu tercih ediyor. Bunun gerekçesi ise, liste
yöntemini performans açısından maliyetli bulmaları.&lt;/p&gt;
&lt;p&gt;Hash tablosunda boş yer bulmak için de kullanılabilecek çeşitli yöntemler var.
Örneğin, İlk bulunan indeksten itibaren sırayla tablo taranabilir, veya ikinci bir
hash fonksiyonu kullanılabilir. Python sözlükleri biraz daha kendine özgü
bir yöntem kullanıyor. Bu yöntemin çekirdeğini oluşturan formül şu şekilde;&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;j = ((5*j) + 1) mod 2**i
&lt;/pre&gt;


&lt;p&gt;Örneğin, kapasitesi 8 olan bir tabloda, çakışan indeks 5 olsun. Bu durumda,
boş yer arama sırası aşağıdaki gibi oluyor;&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;5 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 0 -&amp;gt; 1 -&amp;gt; 6 -&amp;gt; 7 -&amp;gt; 4 -&amp;gt; 5 (burada tekrar başa sarıyor)
&lt;/pre&gt;


&lt;p&gt;Bu formülün özelliği, kendini tekrar etmeden önce tablodaki bütün slotları geziyor olması.
Bununla ilgili detaylı bilgi için, &lt;a href="https://www.google.com.tr/search?q=Linear+Congruential+Method"&gt;Linear Congruential Method&lt;/a&gt;
Google aramasına bakabilirsiniz. &lt;a href="https://www.google.com.tr/search?q=do%C4%9Frusal+sondalama"&gt;Doğrusal Sondalama&lt;/a&gt;
yerine bu yöntemin seçilmesinin önemli nedenlerinden biri, Python hash değerlerinin
ardışık olmaya meyilli olması. Rastgele misali bir sırada ilerlenmesi halinde, hızlı
bir şekilde boş yer bulunması ihtimali yükseliyor. Python, tabloda boş yer ararken
bu yöntemin yanında başka şeyler de kullanıyor. Tam algoritma şu şekilde;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;perturb&lt;/code&gt; değişkenini &lt;code&gt;hash&lt;/code&gt; olarak ata. (Buradaki &lt;code&gt;hash&lt;/code&gt; maskelenmeden önceki hali)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;j = ((5*j) + perturb + 1) mod 2**i&lt;/code&gt; olsun.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;perturb&lt;/code&gt; değikenini PERTURB_SHIFT sabiti kadar (optimum değeri 5 olarak belirlenmiş) sağa kaydır. (&lt;code&gt;perturb &amp;gt;&amp;gt;= PERTURB_SHIFT&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Buradaki &lt;code&gt;perturb&lt;/code&gt; değişkeninin amacı, orjinal hash değerinin üst bitlerini de hesaba katmak.
Böylece, orjinal &lt;code&gt;j = ((5*j) + 1) mod 2**i&lt;/code&gt; dizisinin doğrusal sondalama (en. linear probing)
yöntemine dönüşmesinin önüne geçiliyor. Örneğin, kapasitesi 8 olan bir tabloya, sırasıyla
hash değerleri 16, 32 ve 64 olan elemanlar ekleneceğini düşünelim. Bu durumda, hepsinin
alt 3 biti 0 olacağından, &lt;code&gt;j = ((5*j) + 1) mod 2**i&lt;/code&gt; formülüne göre aynı sırada
boş yer aranacak. Ancak, üst bitler de hesaba dahil edilirse, daha erken boş yer bulma
ihtimalimiz oluşuyor. Eğer döngü yeterince uzun çalışırsa, &lt;code&gt;perturb&lt;/code&gt; değeri sıfırda sabitleneceği için,
döngü tekrar &lt;code&gt;j = ((5*j) + 1) mod 2**i&lt;/code&gt; haline dönüşüyor. Böylece, tablodaki tüm slotların taranacağı
garanti altına alınmış oluyor.&lt;/p&gt;
&lt;p&gt;Peki, ya boş yer kalmamışsa? Boş yer arama sırasında, böyle bir endişe gereksiz, çünkü, tablo
kapasitesi 2/3'e ulaştığında, Python tablonun kapasitesini yükseltiyor. Böylece, tabloda boş
yer olmaması ihtimali ortadan kalkıyor. Tablonun kapasitesini yükseltmek için, geçerli kapasitenin
dört katı (tablo büyükse iki katı) büyüklüğünde hafıza ayrılıp, eski tablodaki bütün girdiler yeni tabloya taşınıyor. Bunun
sıradan bir &lt;code&gt;realloc&lt;/code&gt; veya &lt;code&gt;memcpy&lt;/code&gt; işlemi olmadığına dikkat edin. Tüm elemanların yeni tablodaki
yerleri &lt;code&gt;hash&amp;amp;mask&lt;/code&gt; yöntemiyle hesaplanıp, hash çakışmaları yukarıdaki bahsi geçen yöntemle gideriliyor.&lt;/p&gt;
&lt;p&gt;Tabloya yeni anahtar eklemek ve eklenmiş değerleri bulmak için yukarıda bahsedilen yöntem kullanıyor, ancak,
aramanın sona erdirilmesi kriteri farklı. Tabloya yeni anahtar eklenmek isteniyor ise, yazının başında
bahsedilen, kullanılmamış veya dummy slot bulununcaya kadar arama devam ediyor. Bulunan slot, aktif slot
haline getiriliyor ve eğer gerekli görülürse tablo kapasitesi artırılıyor. Eğer, verilen bir anahtarın
tabloda karşılığı aranıyorsa, önce anahtarın hash değeri bulunuyor. Sonra, yukarıdaki arama yöntemiyle,
hash değeri eşleşen bir slot veya kullanılmamış bir slot bulunana kadar arama sürdürülüyor. Eğer arama
sırasında bir dummy slot bulunursa, bu slot dikkate alınmadan arama sürdürülüyor. dummy slotun amacı,
silinen slotların aramayı erken sonlandırılmasını önlemek. Tablodan
herhangi bir slot silineceği zaman ise, &lt;code&gt;ma_key = dummy&lt;/code&gt;, &lt;code&gt;ma_value = NULL&lt;/code&gt; olarak atanıyor.&lt;/p&gt;
&lt;p&gt;Peki ya tabloya milyonlarca değer ekleyip, sonra geri silerseniz ne olur? Python tablo boyutu ayarlamasını
sadece yeni anahtar eklendikten sonra yaptığı için, sözlüğünüzün hafızada tuttuğu yer azalmaz. Ancak, anahtarları
sildikten sonra, yeni bir anahtar eklemeye kalktığınızda, Python sözlük kapasitesini düşürmeye karar verecektir.&lt;/p&gt;
&lt;p&gt;Daha detaylı bilgi almak için, orjinal &lt;a href="https://github.com/python/cpython/blob/2.7/Objects/dictobject.c"&gt;dictobject.c&lt;/a&gt;
ve &lt;a href="https://github.com/python/cpython/blob/2.7/Include/dictobject.h"&gt;dictobject.h&lt;/a&gt; dosyaları incelenebilir. Python'un
iç işleyişine dair kodlar göz korkutucu olsa da, yorumlardaki açıklamalar oldukça faydalı. Ayrıca, 2015 yılında
Python sözlüklerinden esinlenerek, anahtar ve değerleri string olabilen bir benzer bir veri yapısı yazmıştım. Temel
fikirleri anlatmak açısından faydalı olabileceği düşüncesi ile, &lt;a href="https://github.com/yasar11732/ylib/blob/master/src/dict.c"&gt;kodları GitHub'a yükledim.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Konuyu toplamak gerekirse, sözlük objeleri, Python'un en sık kullanılan veri yapılarından biri olduğu için, üzerine
ciddi kafa yorulmuş. Böyle ustaca tasarlanmış ve optimize edilmiş programları okumak, programlama öğrencileri için
faydalı olacaktır. Python kodlarının geri kalanı, her ne kadar sözlükler kadar iyi belgelendirilmemiş olsa da, github
deposundan ulaşılabiliyor. Biraz göz atılmasını tavsiye ederim.&lt;/p&gt;&lt;/div&gt;</description><category>mathjax</category><guid>http://ysar.net/python/kamera-arkasi-sozlukler.html</guid><pubDate>Sun, 02 Sep 2018 17:43:00 GMT</pubDate></item><item><title>(Euler 17) Sayıların Harf Sayısı</title><link>http://ysar.net/euler/euler-17.html</link><dc:creator>Yaşar Arabacı</dc:creator><description>&lt;div&gt;&lt;p&gt;(Problemin orjinali İngilizce kelimeler üzerine kurulu, ben çevirirken Türkçeleştirdim.)&lt;/p&gt;
&lt;p&gt;1'den 5'e kadar olan sayılar yazıyla bir, iki, üç, dört ve beş olur ve toplamda 3 + 3 + 2 + 4 + 3 = 15 harften oluşur.&lt;/p&gt;
&lt;p&gt;Eğer birden bine kadar (bin dahil) sayılar yazılırsa, kaç harf kullanılır.&lt;/p&gt;
&lt;p&gt;(Not: Boşlukları saymayın. Örneğin, yüz yirmi üç 10 harften oluşur) &lt;/p&gt;&lt;p&gt;&lt;a href="http://ysar.net/euler/euler-17.html"&gt;Devamını oku…&lt;/a&gt; (2 dakikalık okuma)&lt;/p&gt;&lt;/div&gt;</description><category>mathjax</category><guid>http://ysar.net/euler/euler-17.html</guid><pubDate>Sat, 01 Sep 2018 17:40:00 GMT</pubDate></item><item><title>(Euler 16) Büyük Üslü Sayının Haneleri Toplamı</title><link>http://ysar.net/euler/euler-16.html</link><dc:creator>Yaşar Arabacı</dc:creator><description>&lt;div&gt;&lt;p&gt;\(2^{15} = 32768\) ve rakamları toplamı \(3 + 2 + 7 + 6 + 8 = 26\).&lt;/p&gt;
&lt;p&gt;\(2^{1000}\) sayısının rakamları toplamı kaçtır? &lt;/p&gt;&lt;p&gt;&lt;a href="http://ysar.net/euler/euler-16.html"&gt;Devamını oku…&lt;/a&gt; (4 dakikalık okuma)&lt;/p&gt;&lt;/div&gt;</description><category>mathjax</category><guid>http://ysar.net/euler/euler-16.html</guid><pubDate>Sun, 26 Aug 2018 16:47:00 GMT</pubDate></item><item><title>(Euler 15) Izgara Üzerindeki Yollar</title><link>http://ysar.net/euler/euler-15.html</link><dc:creator>Yaşar Arabacı</dc:creator><description>&lt;div&gt;&lt;p&gt;2x2 ızgaranın sol üst köşesinden başlayarak, ve sadece sağa veya aşağıya hareket ederek, sağ alt köşeye tam olarak 6 yol vardır.&lt;/p&gt;
&lt;div style="text-align: center"&gt;
&lt;img src="data:image/gif;base64,R0lGODlh0ACXAMQAAAAAALXf/7fg/7zi/8Tl/8jn/8fo/8zp/9Ts/9nv/93x/+Pz/+v2/+34//P6/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///yH5BAEAAB8AIf4cVWxlYWQgR0lGIFNtYXJ0U2F2ZXIgVmVyIDIuMAAsAAAAANAAlwAABf/gJ45kaZ5oqq7sB7xwLM9ya98ore8v3vLAoHDmyw2DxSTriFSemNAowEmSWoHU6nVL03K/sawLPHWWxeSzUp0mo91msSidZaPrsLs5H5eri2FUdnV4PYR7hmtyLoJ8fXN6iH9JkziBin6NiZiQh5KRlI6Ui5U3l5yMnmuiqICsPqWAmrE2g4KFtLWzt5mfvJ2/q5utsK+WpLvBuT+4oK7DsMi+j6nBodCy06O9wssrttTX3t/JxOamxscj4yrsRtjR2tnOxfCmVfT17jnl2/no9nSt+wdw35N+81Q9M1gC3LmCBH+kExhxyUSK1cItrPjt4hJp3VQxbNhMoT5rGi3/efw40ORJlxBT+hMnkmPHgBg3ykyok9pIfAhn9hS6UyJOlsCKGv3ZMqTSe/ISMk1KE2atle1AVvVpsx1WclHVdX031SHRlyhVgtE6dObUjFufel3LLa5bumH1tYlCCg7XN3jlptg79gmdpmljJr56ePHSmoVNnHoI1alji0fBUqWM+a3noDzRonoLVzRnZnnF2pVat+3ZeJYFk4Vs9XHtnKZfMy4L9LYXJqpPr+NbeTXs0roNAy8ufPhy3Gp5I5Y95sjx5nOeQ1c8unXnJsyTKxdyPfdx0vuslw99E3z46LQvj+fBfn17+vZ3x6eeHUv94EvtIF57+2H3mw4DIhUd/4L/2faXb/MRkaBmC0rYYGcFTiiZgBoO1o2F+TnYXWTOgRjidt9NBiB8yni3Ww0G8iMOjB1uOExmiKEnyVcyyjeYiScS+BtGOn6IY4/8HXjkQfIAKVlvPv7II5IxNqRikHP9wSCSRX4IIYULSRdbdV0wuVmNNpL4pCZqlmglflB2KUybUF5DJ5lv+peUnKG4iKVXfr5oxZ57beFHoYMChigUizTq6KOQRnrfFZJWaumlmKYoRaacduopptp9KuqopIbJYamopqqqjaeu6uqro8IJ66y0glpmrbjmCqmTuvbqq2u/BiusRcMWa+yxyCar7LLMNuvss9BGK+201FZr7f+12Gar7bbcduvtt+CGK+645JZr7rnopqvuuuy2y+qijOICr3qzzKvelSv+mWWUWZVUJZP4vqevlEx95i+aAE9pZpKs8uvhwRcKFDCKArP4L0kQD/zwxKg5PBvDGINWsTocK3jxkCDXadzIUJUMJsJ5erzwmBrL6HK/Mjec8nQrU9yywmvmHPPOZ5rHssRAh0w0nkt7ljTP29z8sNAonwy10T4jveTMMFfd9dUWf92S1FSKzbTVRYcdMWpkc722kGgjh3XHvLQddNNPp300hkunYrfScf8N9t5wm+133npnzXfgilINlOCDK1742zinRncfkCd+ec+bU06w42MjLnf/vmrXfDfNpJMsusEiS1456oSDlfnosX/edON9lzE765abbHbmRe5+Z38FD3+24brbG2+9X4B+vOcbKx/qjM3jHRjm0i9PffZb9q7ppmRy756pXDgvfIbQD+048LjfHrnr493JfsamK83n3PDrHPjqoNxfevpeA6D6GPe+znHHavNrXf4W5j+y0MuA+rGemB7kMOIsMID1w2AGcxSoCOnpgm6S4Jcq10CCjc93/6vdx9ynOQg6UFYgJJ75+Ie+mg1BgDIUoflUhiby4PB5G8whC2mnQuJ1r4gaROIAf8dDAH4wdYv7HQ1b1CYYKlGIUtza6dzSwSzR6IcJ9N7LWFPFvyNCsXBLcpoWATcG1ZRQU+sTxc3UOEEskrCLXlxjAW1nxGXQ0SS8ihMevTjC+JVoYn9EiRkFKb/zxcaKLZxcaCCZkTcapZGbOGEiNaLJJgZRdEREow8juS9FjrKSgwQUJikVyu+JzxBseCUl9SJLUNZyluW63vZuqUdtVU9evOylL1nZqGAKM1w3DFYy3WXCRebqlMz04Oxihcto9hGUpGqVNZtJmlLdapuTWlYgwblEZE1zXceEVTrJyc52MisEADs=" alt=""&gt;
&lt;/div&gt;

&lt;p&gt;20x20 ızgarada bu şekilde kaç adet yol vardır? &lt;/p&gt;&lt;p&gt;&lt;a href="http://ysar.net/euler/euler-15.html"&gt;Devamını oku…&lt;/a&gt; (5 dakikalık okuma)&lt;/p&gt;&lt;/div&gt;</description><category>mathjax</category><guid>http://ysar.net/euler/euler-15.html</guid><pubDate>Fri, 24 Aug 2018 14:55:00 GMT</pubDate></item><item><title>(Euler 14) En Uzun Collatz Dizisi</title><link>http://ysar.net/euler/euler-14.html</link><dc:creator>Yaşar Arabacı</dc:creator><description>&lt;div&gt;&lt;p&gt;Aşağıdaki yinelemeli dizi pozitif tamsayılar kümesi için tanımlanmıştır:&lt;/p&gt;
&lt;p style="margin-left:50px;"&gt;&lt;var&gt;n&lt;/var&gt; → &lt;var&gt;n&lt;/var&gt;/2 (&lt;var&gt;n&lt;/var&gt; çift ise)&lt;br&gt;&lt;var&gt;n&lt;/var&gt; → 3&lt;var&gt;n&lt;/var&gt; + 1 (&lt;var&gt;n&lt;/var&gt; tek ise)&lt;/p&gt;

&lt;p&gt;Yukarıdaki kurala göre, 13 sayısından başlayarak aşağıdaki diziyi elde ederiz:&lt;/p&gt;
&lt;div style="text-align:center;"&gt;13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1&lt;/div&gt;

&lt;p&gt;13 ile başlayıp 1 ile biten bu dizinin 10 elemanlı olduğu görünüyor. Henüz kanıtlanamamış olsa da, tüm başlangıç sayılarının 1 sayısına ulaştığı düşünülüyor.&lt;/p&gt;
&lt;p&gt;Bir milyonun altındaki hangi başlangıç sayısı ile en uzun dizi elde edilir? &lt;/p&gt;&lt;p&gt;&lt;a href="http://ysar.net/euler/euler-14.html"&gt;Devamını oku…&lt;/a&gt; (3 dakikalık okuma)&lt;/p&gt;&lt;/div&gt;</description><category>mathjax</category><guid>http://ysar.net/euler/euler-14.html</guid><pubDate>Thu, 23 Aug 2018 23:21:00 GMT</pubDate></item><item><title>(Euler 13) C Programlama Dilinde Büyük Sayıları Toplama</title><link>http://ysar.net/euler/euler-13.html</link><dc:creator>Yaşar Arabacı</dc:creator><description>&lt;div&gt;&lt;p&gt;Aşağıdaki 100 adet 50 haneli sayının toplamının ilk 10 hanesini bulunuz.&lt;/p&gt;
&lt;div style="font-family:'courier new';font-size:10pt;text-align:center;"&gt;
37107287533902102798797998220837590246510135740250&lt;br&gt;
46376937677490009712648124896970078050417018260538&lt;br&gt;
74324986199524741059474233309513058123726617309629&lt;br&gt;
91942213363574161572522430563301811072406154908250&lt;br&gt;
23067588207539346171171980310421047513778063246676&lt;br&gt;
89261670696623633820136378418383684178734361726757&lt;br&gt;
28112879812849979408065481931592621691275889832738&lt;br&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://ysar.net/euler/euler-13.html"&gt;Devamını oku…&lt;/a&gt; (4 dakikalık okuma)&lt;/p&gt;&lt;/div&gt;</description><category>mathjax</category><guid>http://ysar.net/euler/euler-13.html</guid><pubDate>Thu, 23 Aug 2018 13:36:00 GMT</pubDate></item><item><title>SageMath</title><link>http://ysar.net/yazilim-dunyasi/sage-math.html</link><dc:creator>Yaşar Arabacı</dc:creator><description>&lt;div&gt;&lt;p&gt;Eğer bloğumu takip ediyorsanız, son birkaç haftadır Euler problemi çözümlerimi paylaştığımı biliyorsunuz. Euler Problemleri,
programcılık problemleri olduğu kadar, matematik problemleri de sayılabilir. Bu yazıda, bu problemlerin çözümünde sıklıkla faydalandığım
&lt;a href="http://www.sagemath.org/"&gt;SageMath&lt;/a&gt; programından bahsedeceğim. &lt;/p&gt;&lt;p&gt;&lt;a href="http://ysar.net/yazilim-dunyasi/sage-math.html"&gt;Devamını oku…&lt;/a&gt; (6 dakikalık okuma)&lt;/p&gt;&lt;/div&gt;</description><category>mathjax</category><guid>http://ysar.net/yazilim-dunyasi/sage-math.html</guid><pubDate>Wed, 22 Aug 2018 22:01:00 GMT</pubDate></item><item><title>(Euler 12) Üçgen Sayılar ve Bölenlerinin Sayısı</title><link>http://ysar.net/euler/euler-12.html</link><dc:creator>Yaşar Arabacı</dc:creator><description>&lt;div&gt;&lt;p&gt;Üçgen sayılar sayı dizisi, doğal sayılar eklenerek oluşturulur. Örneğin, 7. üçgen sayı 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28 olur.
İlk 10 terim şu şekildedir.&lt;/p&gt;
&lt;p&gt;1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...&lt;/p&gt;
&lt;p&gt;İlk 7 üçgen sayının bölenlerine bakalım;&lt;/p&gt;
&lt;pre&gt;
 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
&lt;/pre&gt;

&lt;p&gt;5'den fazla böleni olan ilk üçgen sayının 28 olduğunu görüyoruz.&lt;/p&gt;
&lt;p&gt;500'den fazla böleni olan ilk üçgen sayı kaçtır? &lt;/p&gt;&lt;p&gt;&lt;a href="http://ysar.net/euler/euler-12.html"&gt;Devamını oku…&lt;/a&gt; (10 dakikalık okuma)&lt;/p&gt;&lt;/div&gt;</description><category>mathjax</category><guid>http://ysar.net/euler/euler-12.html</guid><pubDate>Wed, 22 Aug 2018 15:06:00 GMT</pubDate></item><item><title>Python ile Hızlı Asal Sayı Tespiti</title><link>http://ysar.net/python/python-ile-hizli-asal-sayi-bulma.html</link><dc:creator>Yaşar Arabacı</dc:creator><description>&lt;div&gt;&lt;p&gt;Normalde bugün Euler Problemleri serisinde 12. yazıyı yazacaktım, ama kendimi asal sayı tespit programlarına biraz fazla kaptırdım. Euler
problemine geçmeden önce, son yazdığım asal sayı bulma fonksiyonunu paylaşayım istedim. &lt;/p&gt;&lt;p&gt;&lt;a href="http://ysar.net/python/python-ile-hizli-asal-sayi-bulma.html"&gt;Devamını oku…&lt;/a&gt; (1 dakikalık okuma)&lt;/p&gt;&lt;/div&gt;</description><category>mathjax</category><guid>http://ysar.net/python/python-ile-hizli-asal-sayi-bulma.html</guid><pubDate>Tue, 21 Aug 2018 20:15:00 GMT</pubDate></item><item><title>(Euler 11) 11. Euler Problemi Çözümü</title><link>http://ysar.net/euler/euler-11.html</link><dc:creator>Yaşar Arabacı</dc:creator><description>&lt;div&gt;&lt;p&gt;Aşağıdaki 20x20 şeklinde dizilmiş sayılardan, köşegen üzerinde bulunan 4 tanesi kırmızıyla işaretlenmiştir.&lt;/p&gt;
&lt;p style="font-family:'courier new';text-align:center;font-size:10pt;"&gt;
08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08&lt;br&gt;
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00&lt;br&gt;
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65&lt;br&gt;
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91&lt;br&gt;
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80&lt;br&gt;
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50&lt;br&gt;
32 98 81 28 64 23 67 10 &lt;span style="color:#ff0000;"&gt;&lt;b&gt;26&lt;/b&gt;&lt;/span&gt; 38 40 67 59 54 70 66 18 38 64 70&lt;br&gt;
67 26 20 68 02 62 12 20 95 &lt;span style="color:#ff0000;"&gt;&lt;b&gt;63&lt;/b&gt;&lt;/span&gt; 94 39 63 08 40 91 66 49 94 21&lt;br&gt;
24 55 58 05 66 73 99 26 97 17 &lt;span style="color:#ff0000;"&gt;&lt;b&gt;78&lt;/b&gt;&lt;/span&gt; 78 96 83 14 88 34 89 63 72&lt;br&gt;
21 36 23 09 75 00 76 44 20 45 35 &lt;span style="color:#ff0000;"&gt;&lt;b&gt;14&lt;/b&gt;&lt;/span&gt; 00 61 33 97 34 31 33 95&lt;br&gt;
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92&lt;br&gt;
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57&lt;br&gt;
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58&lt;br&gt;
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40&lt;br&gt;
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66&lt;br&gt;
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69&lt;br&gt;
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36&lt;br&gt;
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16&lt;br&gt;
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54&lt;br&gt;
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Bu sayıların çarpımı 26 × 63 × 78 × 14 = 1788696 yapar.&lt;/p&gt;
&lt;p&gt;Bu sayıların içerisinde, yatay, dikey veya çapraz olarak ardışık
4 sayının çarpımı en fazla kaçtır? &lt;/p&gt;&lt;p&gt;&lt;a href="http://ysar.net/euler/euler-11.html"&gt;Devamını oku…&lt;/a&gt; (8 dakikalık okuma)&lt;/p&gt;&lt;/div&gt;</description><category>mathjax</category><guid>http://ysar.net/euler/euler-11.html</guid><pubDate>Mon, 20 Aug 2018 18:59:00 GMT</pubDate></item></channel></rss>